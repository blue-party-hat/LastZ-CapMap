<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>LastZ È¶ñÈÉΩ„ÉÜ„É™„Éà„É™„Éº„Éó„É©„É≥„Éä„Éº</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent}

    body{
      font-family:-apple-system,BlinkMacSystemFont,'Segoe UI','Hiragino Sans','Hiragino Kaku Gothic ProN',Meiryo,sans-serif;
      background:#0a0a0a;color:#fff;min-height:100vh;overflow:hidden;
      display: flex;
      flex-direction: column;
    }

    .header{
      background:rgba(20,20,20,.95);
      backdrop-filter:blur(20px);
      padding:15px 20px;
      display:flex;justify-content:center;align-items:center;
      border-bottom:1px solid rgba(255,255,255,.1);
      box-shadow:0 4px 30px rgba(0,0,0,.5);
      flex-shrink: 0;
      z-index: 20;
    }

    h1{
      font-size:clamp(1.1em,3.5vw,2em);
      font-weight:700;letter-spacing:1px;color:#fff;
      text-shadow:0 0 20px rgba(255,255,255,.3);
    }

    /* Legend Area - Top horizontal strip on mobile, absolute top-right on desktop */
    .legend-container {
        position: absolute;
        top: 15px;
        right: 15px;
        background: rgba(20, 20, 20, 0.95);
        backdrop-filter: blur(20px);
        padding: 15px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
        max-width: 200px;
        max-height: 40vh;
        overflow-y: auto;
        z-index: 10;
        transition: all 0.3s ease;
    }

    .legend-container h3 {
        margin-bottom: 12px;
        font-size: 1em;
        font-weight: 600;
        color: #c0c0c0;
        white-space: nowrap;
    }

    #legendList {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }

    .legend-item {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 0.85em;
        padding: 8px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.05);
    }

    .legend-color {
        width: 30px;
        height: 20px;
        border-radius: 4px;
        border: 1px solid rgba(255, 255, 255, 0.3);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
        flex-shrink: 0;
    }

    .legend-name {
        flex: 1;
        color: #e0e0e0;
        word-break: break-word;
    }

    .delete-alliance-btn {
        background: rgba(255, 50, 50, 0.2);
        border: 1px solid rgba(255, 50, 50, 0.3);
        color: #ff6b6b;
        width: 24px;
        height: 24px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
        flex-shrink: 0;
        /* Ensure it's clickable */
        pointer-events: auto;
        touch-action: manipulation;
    }

    .delete-alliance-btn:hover {
        background: rgba(255, 50, 50, 0.4);
        border-color: rgba(255, 50, 50, 0.6);
        transform: scale(1.06);
    }

    /* Instructions Area - Bottom horizontal strip on mobile, absolute bottom-left on desktop */
    .instructions-container {
        position: absolute;
        bottom: 15px;
        left: 15px;
        background: rgba(20, 20, 20, 0.95);
        backdrop-filter: blur(20px);
        padding: 15px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
        max-width: 200px;
        z-index: 10;
        pointer-events: none; /* Let clicks pass through if needed, though text selection might be wanted */
    }

    .instructions-container h4 {
        margin-bottom: 10px;
        color: #c0c0c0;
        font-size: 1em;
        font-weight: 600;
    }

    .instructions-content {
        display: flex;
        flex-direction: column;
        gap: 6px;
    }

    .instructions-container p {
        line-height: 1.5;
        color: #a0a0a0;
        font-size: 0.8em;
    }

    .main-container{
      flex: 1;
      display:flex;justify-content:center;align-items:center;
      position:relative;
      overflow: hidden;
      width: 100%;
    }

    #hexCanvas{
      cursor:crosshair;
      max-width:85vmin;max-height:85vmin;
      filter:drop-shadow(0 0 30px rgba(255,255,255,.1));
      touch-action:none;
    }

    /* Modal Styles (Unchanged) */
    .modal{
      display:none;position:fixed;z-index:1000;left:0;top:0;width:100%;height:100%;
      background:rgba(0,0,0,.85);
      backdrop-filter:blur(10px);
      animation:fadeIn .25s ease;
    }
    @keyframes fadeIn{from{opacity:0}to{opacity:1}}
    .modal-content{
      position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
      background:#1a1a1a;
      padding:25px;border-radius:16px;
      box-shadow:0 20px 60px rgba(0,0,0,.9);
      width:450px;max-width:92%;
      max-height:90vh;overflow-y:auto;
      border:1px solid rgba(255,255,255,.1);
      animation:slideUp .25s ease;
    }
    @keyframes slideUp{from{transform:translate(-50%,-40%);opacity:0}to{transform:translate(-50%,-50%);opacity:1}}
    .modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;padding-bottom:12px;border-bottom:1px solid rgba(255,255,255,.1)}
    .modal-title{font-size:1.3em;font-weight:700;color:#fff}
    .close-btn{
      background:rgba(255,255,255,.1);border:1px solid rgba(255,255,255,.1);color:#fff;
      font-size:1.3em;cursor:pointer;line-height:1;width:35px;height:35px;
      display:flex;align-items:center;justify-content:center;border-radius:8px;transition:all .2s;
    }
    .close-btn:hover{background:rgba(255,255,255,.2);transform:rotate(90deg)}
    .selection-info{background:rgba(255,255,255,.05);border:1px solid rgba(255,255,255,.1);border-radius:10px;padding:15px;margin-bottom:20px;text-align:center;}
    .selection-info strong{font-size:1.2em;color:#fff;font-weight:700}
    .form-section{margin-bottom:20px}
    .form-section h3{font-size:1em;margin-bottom:12px;color:#c0c0c0;font-weight:600}
    .input-group{margin-bottom:15px}
    .input-group label{display:block;margin-bottom:8px;font-weight:600;font-size:.95em;color:#c0c0c0}
    .input-group input[type="text"]{
      width:100%;padding:12px;border:1px solid rgba(255,255,255,.2);border-radius:8px;font-size:16px;background:rgba(255,255,255,.05);color:#fff;transition:all .2s;font-weight:500;
    }
    .input-group input[type="text"]:focus{outline:none;border-color:rgba(255,255,255,.4);background:rgba(255,255,255,.1);box-shadow:0 0 20px rgba(255,255,255,.1);}
    .color-picker-wrapper{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
    .color-option{height:50px;border-radius:8px;border:2px solid transparent;cursor:pointer;transition:all .2s;position:relative;box-shadow:0 4px 15px rgba(0,0,0,.3);}
    .color-option:hover{transform:scale(1.06);box-shadow:0 6px 20px rgba(0,0,0,.5)}
    .color-option.selected{border-color:#fff;box-shadow:0 0 18px rgba(255,255,255,.45);transform:scale(1.03)}
    .color-option.selected::after{content:'‚úì';position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#fff;font-size:1.6em;font-weight:800;text-shadow:0 2px 8px rgba(0,0,0,.8);}
    .modal-actions{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .modal-btn{padding:14px;border:1px solid rgba(255,255,255,.2);border-radius:8px;font-size:1em;font-weight:700;cursor:pointer;transition:all .2s;background:rgba(255,255,255,.05);color:#fff;}
    .modal-btn:active{transform:scale(.98)}
    .btn-clear-selection:hover{background:rgba(255,50,50,.2);border-color:rgba(255,50,50,.5)}
    .btn-place:hover{background:rgba(255,255,255,.15);border-color:rgba(255,255,255,.4)}

    /* Mobile Layout Updates */
    @media (max-width: 768px) {
        body {
            height: 100vh;
            overflow: hidden; /* Prevent body scroll */
        }

        .header {
            padding: 10px 15px;
            height: 50px;
        }

        .main-container {
            display: flex;
            flex-direction: column;
            justify-content: space-between; /* Push canvas to middle */
            height: calc(100vh - 50px);
            padding: 0;
            background: #0a0a0a;
        }

        #hexCanvas {
            /* Limit canvas size to ensure it doesn't overlap top/bottom bars */
            max-width: 100%;
            max-height: calc(100% - 140px); /* Reserve space for top and bottom bars */
            margin: auto;
        }

        /* Top Bar: Legend (Horizontal) */
        .legend-container {
            position: relative;
            top: 0;
            right: 0;
            width: 100%;
            max-width: none;
            max-height: none;
            border-radius: 0;
            border-left: none;
            border-right: none;
            background: rgba(20, 20, 20, 0.98);
            padding: 8px 12px;
            display: flex;
            align-items: center;
            overflow-x: auto; /* Horizontal scroll */
            white-space: nowrap;
            flex-shrink: 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .legend-container h3 {
            margin: 0;
            margin-right: 15px;
            font-size: 0.9em;
        }

        #legendList {
            flex-direction: row;
            gap: 10px;
        }

        .legend-item {
            padding: 5px 10px;
            margin: 0;
            background: rgba(255, 255, 255, 0.08);
            flex-shrink: 0;
        }

        .legend-name {
            font-size: 0.9em;
        }

        /* Bottom Bar: Instructions (Horizontal) */
        .instructions-container {
            position: relative;
            bottom: 0;
            left: 0;
            width: 100%;
            max-width: none;
            border-radius: 0;
            border-left: none;
            border-right: none;
            background: rgba(20, 20, 20, 0.98);
            padding: 8px 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            border-top: 1px solid rgba(255,255,255,0.1);
            pointer-events: auto;
        }

        .instructions-container h4 {
            display: none; /* Hide title to save space on mobile */
        }

        .instructions-content {
            flex-direction: row;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .instructions-container p {
            margin: 0;
            font-size: 0.75em;
            color: #ccc;
        }

        .modal-content {
            width: 95%;
            padding: 20px;
        }
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>LastZ È¶ñÈÉΩ„ÉÜ„É™„Éà„É™„Éº„Éó„É©„É≥„Éä„Éº</h1>
  </div>

  <div class="main-container">
    <!-- Top Horizontal Legend (Mobile) / Absolute Right (Desktop) -->
    <div class="legend-container">
      <h3>ÈÖçÁΩÆÊ∏à„Åø:</h3>
      <div id="legendList"></div>
    </div>

    <canvas id="hexCanvas" width="900" height="900"></canvas>

    <!-- Bottom Horizontal Instructions (Mobile) / Absolute Left (Desktop) -->
    <div class="instructions-container">
      <h4>‰Ωø„ÅÑÊñπ</h4>
      <div class="instructions-content">
        <p>üëÜ <strong>„Çø„ÉÉ„Éó</strong>: ÈÅ∏Êäû</p>
        <p>üñê <strong>„Éâ„É©„ÉÉ„Ç∞</strong>: Ë§áÊï∞ÈÅ∏Êäû</p>
        <p>‚öôÔ∏è <strong>Ë®≠ÂÆö</strong>: Ëâ≤/ÂêçÂâç</p>
      </div>
    </div>
  </div>

  <!-- Modal -->
  <div id="assignModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <span class="modal-title">ÂêåÁõü„ÇíÈÖçÁΩÆ</span>
        <button class="close-btn" onclick="closeModal()">&times;</button>
      </div>
      <div class="selection-info">
        <strong id="selectionLabel">0 „Ç®„É™„Ç¢ÈÅ∏Êäû‰∏≠</strong>
      </div>
      <div class="form-section">
        <h3>ÂêåÁõüÊÉÖÂ†±</h3>
        <div class="input-group">
          <label for="allianceName">ÂêåÁõüÂêç</label>
          <input type="text" id="allianceName" placeholder="„ÉÜ„Ç≠„Çπ„Éà„ÇíÂÖ•Âäõ" maxlength="20" />
        </div>
      </div>
      <div class="form-section">
        <h3>„Ç´„É©„ÉºÈÅ∏Êäû</h3>
        <div class="color-picker-wrapper" id="colorPicker"></div>
      </div>
      <div class="modal-actions">
        <button class="modal-btn btn-clear-selection" onclick="clearSelection()">„ÇØ„É™„Ç¢</button>
        <button class="modal-btn btn-place" onclick="assignAlliance()">ÈÖçÁΩÆ</button>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('hexCanvas');
    const ctx = canvas.getContext('2d');

    let sections = {};
    let isDragging = false;
    let dragStartSection = null;
    let selectedSections = [];

    const colors = [
      '#FF6B6B', '#4ECDC4', '#FFE66D',
      '#A8E6CF', '#FF8B94', '#95E1D3',
      '#C7CEEA', '#FFAAA5', '#B4A7D6'
    ];

    let selectedColor = colors[0];

    const centerX = 450;
    const centerY = 450;
    const hexRadius = 350;
    const innerHexRadius = 120;

    const sectionPaths = [];

    function getHexagonVertex(index, radius) {
      const angle = (Math.PI / 3) * index;
      return {
        x: centerX + radius * Math.cos(angle),
        y: centerY + radius * Math.sin(angle)
      };
    }

    function initSections() {
      for (let i = 0; i < 24; i++) {
        sectionPaths.push({ id: i, path: null });
      }
    }

    function shouldHideLine(id1, id2) {
      if (sections[id1] && sections[id2]) {
        return sections[id1].groupId === sections[id2].groupId;
      }
      return false;
    }

    function isPointInInnerHexagon(canvasX, canvasY) {
      const p = { x: canvasX, y: canvasY };
      const poly = [];
      for (let i = 0; i < 6; i++) poly.push(getHexagonVertex(i, innerHexRadius));
      let inside = false;
      for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
        const xi = poly[i].x, yi = poly[i].y;
        const xj = poly[j].x, yj = poly[j].y;
        const intersect = ((yi > p.y) !== (yj > p.y)) &&
          (p.x < (xj - xi) * (p.y - yi) / (yj - yi + 0.000001) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    function drawHexagon() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#0a0a0a';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = '#1a1a1a';
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const v = getHexagonVertex(i, hexRadius);
        if (i === 0) ctx.moveTo(v.x, v.y);
        else ctx.lineTo(v.x, v.y);
      }
      ctx.closePath();
      ctx.fill();

      for (let i = 0; i < 24; i++) {
        const sideIndex = Math.floor(i / 4);
        const positionOnSide = i % 4;
        const v1 = getHexagonVertex(sideIndex, hexRadius);
        const v2 = getHexagonVertex(sideIndex + 1, hexRadius);
        const ratio1 = positionOnSide / 4;
        const ratio2 = (positionOnSide + 1) / 4;
        const edgePoint1 = {
          x: v1.x + (v2.x - v1.x) * ratio1,
          y: v1.y + (v2.y - v1.y) * ratio1
        };
        const edgePoint2 = {
          x: v1.x + (v2.x - v1.x) * ratio2,
          y: v1.y + (v2.y - v1.y) * ratio2
        };

        const path = new Path2D();
        path.moveTo(centerX, centerY);
        path.lineTo(edgePoint1.x, edgePoint1.y);
        path.lineTo(edgePoint2.x, edgePoint2.y);
        path.closePath();

        sectionPaths[i].path = path;

        if (sections[i]) {
          ctx.fillStyle = sections[i].color;
          ctx.fill(path);
        } else if (selectedSections.includes(i)) {
          ctx.fillStyle = selectedColor + '60';
          ctx.fill(path);
        }
      }

      for (let i = 0; i < 24; i++) {
        const sideIndex = Math.floor(i / 4);
        const positionOnSide = i % 4;
        const v1 = getHexagonVertex(sideIndex, hexRadius);
        const v2 = getHexagonVertex(sideIndex + 1, hexRadius);
        const ratio2 = (positionOnSide + 1) / 4;
        const edgePoint2 = {
          x: v1.x + (v2.x - v1.x) * ratio2,
          y: v1.y + (v2.y - v1.y) * ratio2
        };
        const nextId = (i + 1) % 24;
        if (!shouldHideLine(i, nextId)) {
          ctx.strokeStyle = 'rgba(255,255,255,0.15)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(edgePoint2.x, edgePoint2.y);
          ctx.stroke();
        }
      }

      ctx.fillStyle = '#8B5A3C';
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const v = getHexagonVertex(i, innerHexRadius);
        if (i === 0) ctx.moveTo(v.x, v.y);
        else ctx.lineTo(v.x, v.y);
      }
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,0.35)';
      ctx.lineWidth = 2;
      ctx.stroke();

      const turrets = [
        { index: 4, label: 'T1' },
        { index: 2, label: 'T2' },
        { index: 0, label: 'T3' }
      ];

      turrets.forEach(turret => {
        const v = getHexagonVertex(turret.index, innerHexRadius);
        ctx.fillStyle = '#2196F3';
        ctx.beginPath();
        ctx.arc(v.x, v.y, 18, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 16px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(turret.label, v.x, v.y);
      });

      ctx.strokeStyle = 'rgba(255,255,255,0.28)';
      ctx.lineWidth = 2;
      ctx.shadowBlur = 15;
      ctx.shadowColor = 'rgba(255,255,255,0.25)';
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const v = getHexagonVertex(i, hexRadius);
        if (i === 0) ctx.moveTo(v.x, v.y);
        else ctx.lineTo(v.x, v.y);
      }
      ctx.closePath();
      ctx.stroke();
      ctx.shadowBlur = 0;

      ctx.fillStyle = '#2196F3';
      ctx.beginPath();
      ctx.arc(centerX, centerY, 35, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 3;
      ctx.stroke();
      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold 32px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('C', centerX, centerY);

      const drawnGroups = new Set();
      Object.keys(sections).forEach(id => {
        if (sections[id].name && !drawnGroups.has(sections[id].groupId)) {
          drawnGroups.add(sections[id].groupId);
          const groupSections = Object.keys(sections)
            .filter(gid => sections[gid].groupId === sections[id].groupId)
            .map(gid => parseInt(gid, 10));
          let avgX = 0;
          let avgY = 0;
          groupSections.forEach(i => {
            const sideIndex = Math.floor(i / 4);
            const positionOnSide = i % 4;
            const v1 = getHexagonVertex(sideIndex, hexRadius);
            const v2 = getHexagonVertex(sideIndex + 1, hexRadius);
            const ratio = (positionOnSide + 0.5) / 4;
            const edgeX = v1.x + (v2.x - v1.x) * ratio;
            const edgeY = v1.y + (v2.y - v1.y) * ratio;
            avgX += (centerX + edgeX) / 2;
            avgY += (centerY + edgeY) / 2;
          });
          avgX /= groupSections.length;
          avgY /= groupSections.length;
          let angle = Math.atan2(avgY - centerY, avgX - centerX);
          if (avgY > centerY) angle += Math.PI;
          ctx.save();
          ctx.translate(avgX, avgY);
          ctx.rotate(angle + Math.PI / 2);
          ctx.fillStyle = '#fff';
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 3;
          ctx.font = 'bold 14px sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.strokeText(sections[id].name, 0, 0);
          ctx.fillText(sections[id].name, 0, 0);
          ctx.restore();
        }
      });
      updateLegend();
    }

    function getClickedSection(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const canvasX = (clientX - rect.left) * scaleX;
      const canvasY = (clientY - rect.top) * scaleY;
      if (isPointInInnerHexagon(canvasX, canvasY)) return null;
      for (const section of sectionPaths) {
        if (section.path && ctx.isPointInPath(section.path, canvasX, canvasY)) {
          return section;
        }
      }
      return null;
    }

    function getSectionsInRange(start, end) {
      if (start === null || end === null) return [];
      if (start > end) [start, end] = [end, start];
      const result = [];
      for (let i = start; i <= end; i++) {
        if (!sections[i]) result.push(i);
      }
      return result;
    }

    canvas.addEventListener('mousedown', (e) => {
      e.preventDefault();
      const section = getClickedSection(e.clientX, e.clientY);
      if (!section || sections[section.id]) return;
      isDragging = true;
      dragStartSection = section.id;
      selectedSections = [section.id];
      drawHexagon();
    });

    canvas.addEventListener('mousemove', (e) => {
      if (!isDragging || dragStartSection === null) return;
      const section = getClickedSection(e.clientX, e.clientY);
      if (!section || sections[section.id]) return;
      selectedSections = getSectionsInRange(dragStartSection, section.id);
      if (selectedSections.length === 0) selectedSections = [dragStartSection];
      drawHexagon();
    });

    window.addEventListener('mouseup', () => {
      if (isDragging && selectedSections.length > 0) openModal();
      isDragging = false;
      dragStartSection = null;
    });

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const t = e.touches[0];
      const section = getClickedSection(t.clientX, t.clientY);
      if (!section || sections[section.id]) return;
      isDragging = true;
      dragStartSection = section.id;
      selectedSections = [section.id];
      drawHexagon();
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (!isDragging || dragStartSection === null) return;
      const t = e.touches[0];
      const section = getClickedSection(t.clientX, t.clientY);
      if (!section || sections[section.id]) return;
      selectedSections = getSectionsInRange(dragStartSection, section.id);
      if (selectedSections.length === 0) selectedSections = [dragStartSection];
      drawHexagon();
    }, { passive: false });

    window.addEventListener('touchend', (e) => {
      if (isDragging && selectedSections.length > 0) openModal();
      isDragging = false;
      dragStartSection = null;
    });

    function openModal() {
      document.getElementById('assignModal').style.display = 'block';
      document.getElementById('selectionLabel').textContent = `${selectedSections.length} „Ç®„É™„Ç¢ÈÅ∏Êäû‰∏≠`;
      setTimeout(() => document.getElementById('allianceName').focus(), 50);
    }

    function closeModal() {
      document.getElementById('assignModal').style.display = 'none';
      selectedSections = [];
      dragStartSection = null;
      drawHexagon();
    }

    function initColorPicker() {
      const picker = document.getElementById('colorPicker');
      picker.innerHTML = '';
      colors.forEach((color, index) => {
        const option = document.createElement('div');
        option.className = 'color-option' + (index === 0 ? ' selected' : '');
        option.style.background = color;
        option.addEventListener('click', () => {
          selectedColor = color;
          document.querySelectorAll('.color-option').forEach(opt => opt.classList.remove('selected'));
          option.classList.add('selected');
          drawHexagon();
        });
        picker.appendChild(option);
      });
    }

    function assignAlliance() {
      const name = document.getElementById('allianceName').value.trim();
      if (!name) {
        alert('ÂêåÁõüÂêç„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºÅ');
        return;
      }
      const groupId = Date.now();
      selectedSections.forEach(id => {
        sections[id] = { name, color: selectedColor, groupId };
      });
      document.getElementById('allianceName').value = '';
      closeModal();
      drawHexagon();
    }

    function clearSelection() {
      document.getElementById('allianceName').value = '';
      closeModal();
    }

    // Attach to window so it's accessible by onclick even with module scoping
    window.deleteAlliance = function(allianceName) {
      if (confirm(`„Äå${allianceName}„Äç„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü`)) {
        Object.keys(sections).forEach(id => {
          if (sections[id].name === allianceName) delete sections[id];
        });
        drawHexagon();
      }
    };

    function updateLegend() {
      const legendList = document.getElementById('legendList');
      legendList.innerHTML = '';
      if (Object.keys(sections).length === 0) {
        legendList.innerHTML = '<div style="color: rgba(255,255,255,0.5); font-size: 0.9em; padding: 0 10px; white-space: nowrap;">ÈÖçÁΩÆ„Å™„Åó</div>';
        return;
      }
      const uniqueAlliances = {};
      Object.values(sections).forEach(s => { uniqueAlliances[s.name] = s.color; });
      Object.entries(uniqueAlliances).forEach(([name, color]) => {
        const item = document.createElement('div');
        item.className = 'legend-item';
        // Need to escape single quotes safely for the onclick handler
        const safeName = name.replace(/'/g, "\\'");
        item.innerHTML = `
          <div class="legend-color" style="background:${color}"></div>
          <span class="legend-name">${name}</span>
          <button class="delete-alliance-btn" type="button" onclick="window.deleteAlliance('${safeName}')">‚úï</button>
        `;
        legendList.appendChild(item);
      });
    }

    function init() {
      initSections();
      initColorPicker();
      drawHexagon();
    }

    init();
  </script>
</body>
</html>
