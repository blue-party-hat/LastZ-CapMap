<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>LastZ 首都テリトリープランナー</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent}

    body{
      font-family:-apple-system,BlinkMacSystemFont,'Segoe UI','Hiragino Sans','Hiragino Kaku Gothic ProN',Meiryo,sans-serif;
      background:#0a0a0a;color:#fff;min-height:100vh;overflow:hidden;
      display:flex;flex-direction:column;
    }

    .header{
      background:rgba(20,20,20,.95);
      backdrop-filter:blur(20px);
      padding:15px 20px;
      display:flex;justify-content:center;align-items:center;
      border-bottom:1px solid rgba(255,255,255,.1);
      box-shadow:0 4px 30px rgba(0,0,0,.5);
      flex-shrink:0;
      z-index:20;
    }

    h1{
      font-size:clamp(1.05em,3.5vw,2em);
      font-weight:700;letter-spacing:1px;color:#fff;
      text-shadow:0 0 20px rgba(255,255,255,.3);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width:92vw;
    }

    .main-container{
      flex:1;
      display:flex;
      justify-content:center;
      align-items:center;
      position:relative;
      overflow:hidden;
      width:100%;
    }

    /* Desktop floating legend */
    .legend-container{
      position:absolute;
      top:15px;right:15px;
      background:rgba(20,20,20,.95);
      backdrop-filter:blur(20px);
      padding:15px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.1);
      box-shadow:0 8px 32px rgba(0,0,0,.8);
      max-width:240px;
      max-height:45vh;
      overflow:auto;
      z-index:10;
    }

    .legend-container h3{margin:0 0 12px 0;font-size:1em;font-weight:600;color:#c0c0c0;white-space:nowrap}

    #legendList{display:flex;flex-direction:column;gap:8px}

    .legend-item{
      display:flex;align-items:center;gap:8px;
      font-size:.85em;
      padding:8px;
      background:rgba(255,255,255,.05);
      border-radius:8px;
      border:1px solid rgba(255,255,255,.05);
    }

    .legend-color{
      width:30px;height:20px;border-radius:4px;
      border:1px solid rgba(255,255,255,.3);
      box-shadow:0 2px 8px rgba(0,0,0,.5);
      flex-shrink:0;
    }

    .legend-name{flex:1;color:#e0e0e0;word-break:break-word}

    .delete-alliance-btn{
      background:rgba(255,50,50,.2);
      border:1px solid rgba(255,50,50,.35);
      color:#ff6b6b;
      width:24px;height:24px;border-radius:4px;
      cursor:pointer;
      font-size:14px;
      display:flex;align-items:center;justify-content:center;
      transition:all .2s;
      flex-shrink:0;
      pointer-events:auto;
      touch-action:manipulation;
    }

    .delete-alliance-btn:hover{background:rgba(255,50,50,.4);border-color:rgba(255,50,50,.6);transform:scale(1.06)}

    /* Desktop floating instructions */
    .instructions-container{
      position:absolute;
      bottom:15px;left:15px;
      background:rgba(20,20,20,.95);
      backdrop-filter:blur(20px);
      padding:15px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.1);
      box-shadow:0 8px 32px rgba(0,0,0,.8);
      max-width:260px;
      z-index:10;
      pointer-events:none;
    }

    .instructions-container h4{margin:0 0 10px 0;color:#c0c0c0;font-size:1em;font-weight:600}
    .instructions-container p{margin:0 0 6px 0;line-height:1.5;color:#a0a0a0;font-size:.85em}

    #gridCanvas{
      cursor:crosshair;
      max-width:88vmin;
      max-height:88vmin;
      filter:drop-shadow(0 0 30px rgba(255,255,255,.1));
      touch-action:none;
    }

    /* Modal */
    .modal{display:none;position:fixed;z-index:1000;left:0;top:0;width:100%;height:100%;background:rgba(0,0,0,.85);backdrop-filter:blur(10px);animation:fadeIn .25s ease}
    @keyframes fadeIn{from{opacity:0}to{opacity:1}}
    .modal-content{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:#1a1a1a;padding:22px;border-radius:16px;box-shadow:0 20px 60px rgba(0,0,0,.9);width:480px;max-width:92%;max-height:90vh;overflow:auto;border:1px solid rgba(255,255,255,.1)}
    .modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;padding-bottom:10px;border-bottom:1px solid rgba(255,255,255,.1)}
    .modal-title{font-size:1.25em;font-weight:700;color:#fff}
    .close-btn{background:rgba(255,255,255,.1);border:1px solid rgba(255,255,255,.1);color:#fff;font-size:1.3em;cursor:pointer;line-height:1;width:35px;height:35px;display:flex;align-items:center;justify-content:center;border-radius:8px;transition:all .2s}
    .close-btn:hover{background:rgba(255,255,255,.2);transform:rotate(90deg)}
    .selection-info{background:rgba(255,255,255,.05);border:1px solid rgba(255,255,255,.1);border-radius:10px;padding:14px;margin-bottom:16px;text-align:center}
    .selection-info strong{font-size:1.15em;color:#fff;font-weight:800}
    .form-section{margin-bottom:16px}
    .form-section h3{font-size:1em;margin-bottom:10px;color:#c0c0c0;font-weight:600}
    .input-group{margin-bottom:14px}
    .input-group label{display:block;margin-bottom:8px;font-weight:600;font-size:.95em;color:#c0c0c0}
    .input-group input[type="text"]{width:100%;padding:12px;border:1px solid rgba(255,255,255,.2);border-radius:8px;font-size:16px;background:rgba(255,255,255,.05);color:#fff;transition:all .2s;font-weight:500}
    .input-group input[type="text"]:focus{outline:none;border-color:rgba(255,255,255,.4);background:rgba(255,255,255,.1);box-shadow:0 0 20px rgba(255,255,255,.1)}
    .color-picker-wrapper{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
    .color-option{height:46px;border-radius:8px;border:2px solid transparent;cursor:pointer;transition:all .2s;position:relative;box-shadow:0 4px 15px rgba(0,0,0,.3)}
    .color-option:hover{transform:scale(1.05);box-shadow:0 6px 20px rgba(0,0,0,.5)}
    .color-option.selected{border-color:#fff;box-shadow:0 0 18px rgba(255,255,255,.45);transform:scale(1.02)}
    .color-option.selected::after{content:'✓';position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#fff;font-size:1.6em;font-weight:800;text-shadow:0 2px 8px rgba(0,0,0,.8)}
    .modal-actions{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .modal-btn{padding:13px;border:1px solid rgba(255,255,255,.2);border-radius:8px;font-size:1em;font-weight:800;cursor:pointer;transition:all .2s;background:rgba(255,255,255,.05);color:#fff}
    .modal-btn:active{transform:scale(.98)}
    .btn-clear-selection:hover{background:rgba(255,50,50,.2);border-color:rgba(255,50,50,.5)}
    .btn-place:hover{background:rgba(255,255,255,.15);border-color:rgba(255,255,255,.4)}

    /* Mobile: top horizontal legend, bottom horizontal how-to */
    @media (max-width:768px){
      .header{padding:10px 12px;height:50px}
      .main-container{flex-direction:column;justify-content:space-between;height:calc(100vh - 50px)}
      #gridCanvas{max-width:100%;max-height:calc(100% - 140px);margin:auto}

      .legend-container{
        position:relative;top:0;right:0;
        width:100%;max-width:none;max-height:none;
        border-radius:0;
        border-left:none;border-right:none;
        padding:8px 10px;
        display:flex;align-items:center;
        overflow-x:auto;overflow-y:hidden;
        white-space:nowrap;
        border-bottom:1px solid rgba(255,255,255,.1);
        background:rgba(20,20,20,.98);
      }
      .legend-container h3{margin:0;margin-right:12px;font-size:.9em}
      #legendList{flex-direction:row;gap:10px}
      .legend-item{padding:6px 10px;margin:0;flex-shrink:0;background:rgba(255,255,255,.08)}

      .instructions-container{
        position:relative;bottom:0;left:0;
        width:100%;max-width:none;
        border-radius:0;
        border-left:none;border-right:none;
        padding:8px 10px;
        display:flex;align-items:center;justify-content:center;
        border-top:1px solid rgba(255,255,255,.1);
        background:rgba(20,20,20,.98);
        pointer-events:auto;
      }
      .instructions-container h4{display:none}
      .instructions-container p{margin:0;color:#ccc;font-size:.78em}
      .instructions-inline{display:flex;gap:14px;flex-wrap:wrap;justify-content:center}
      .instructions-container .desktop-only{display:none}
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>LastZ 首都テリトリープランナー</h1>
  </div>

  <div class="main-container">
    <div class="legend-container">
      <h3>配置済み:</h3>
      <div id="legendList"></div>
    </div>

    <canvas id="gridCanvas" width="960" height="960"></canvas>

    <div class="instructions-container">
      <h4>使い方</h4>
      <div class="instructions-inline">
        <p><strong>タップ</strong>: 選択</p>
        <p><strong>ドラッグ</strong>: 複数</p>
        <p><strong>設定</strong>: 色/名前</p>
      </div>
      <div class="desktop-only">
        <p><strong>クリック</strong>：1つ選択</p>
        <p><strong>ドラッグ</strong>：複数選択</p>
      </div>
    </div>
  </div>

  <div id="assignModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <span class="modal-title">同盟を配置</span>
        <button class="close-btn" onclick="closeModal()">&times;</button>
      </div>
      <div class="selection-info">
        <strong id="selectionLabel">0 マス選択中</strong>
      </div>
      <div class="form-section">
        <h3>同盟情報</h3>
        <div class="input-group">
          <label for="allianceName">同盟名</label>
          <input type="text" id="allianceName" placeholder="テキストを入力" maxlength="20" />
        </div>
      </div>
      <div class="form-section">
        <h3>カラー選択</h3>
        <div class="color-picker-wrapper" id="colorPicker"></div>
      </div>
      <div class="modal-actions">
        <button class="modal-btn btn-clear-selection" onclick="clearSelection()">クリア</button>
        <button class="modal-btn btn-place" onclick="assignAlliance()">配置</button>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gridCanvas');
    const ctx = canvas.getContext('2d');

    // Palette (9)
    const colors = [
      '#FF6B6B', '#4ECDC4', '#FFE66D',
      '#A8E6CF', '#FF8B94', '#95E1D3',
      '#C7CEEA', '#FFAAA5', '#B4A7D6'
    ];
    let selectedColor = colors[0];

    // Geometry
    const W = canvas.width;
    const H = canvas.height;
    const centerX = W/2;
    const centerY = H/2;

    // Outer hex + inner hex
    const outerRadius = 410;
    const innerRadius = 140;

    // Square grid settings
    const gridSize = 30;

    // Data: selected squares during drag, and placed squares
    // key = "c,r" (col,row)
    const placed = new Map(); // key -> { name, color, groupId }
    let selected = new Set();

    let isDragging = false;
    let dragStartKey = null;

    function hexVertex(i, radius) {
      // flat-top hex
      const angle = (Math.PI/3)*i;
      return { x: centerX + radius*Math.cos(angle), y: centerY + radius*Math.sin(angle) };
    }

    function buildHexPath(radius) {
      const p = new Path2D();
      for (let i=0;i<6;i++) {
        const v = hexVertex(i, radius);
        if (i===0) p.moveTo(v.x, v.y);
        else p.lineTo(v.x, v.y);
      }
      p.closePath();
      return p;
    }

    const outerHexPath = buildHexPath(outerRadius);
    const innerHexPath = buildHexPath(innerRadius);

    function pointInOuterHex(x,y){
      return ctx.isPointInPath(outerHexPath, x, y);
    }
    function pointInInnerHex(x,y){
      return ctx.isPointInPath(innerHexPath, x, y);
    }

    // Convert canvas point to grid cell (col,row)
    function pointToCell(x,y){
      const col = Math.floor(x / gridSize);
      const row = Math.floor(y / gridSize);
      return { col, row, key: `${col},${row}` };
    }

    function cellRect(col,row){
      return { x: col*gridSize, y: row*gridSize, w: gridSize, h: gridSize };
    }

    // Only allow cells whose CENTER lies inside the outer hex and outside inner hex.
    function cellIsPlayable(col,row){
      const r = cellRect(col,row);
      const cx = r.x + r.w/2;
      const cy = r.y + r.h/2;
      if (!pointInOuterHex(cx,cy)) return false;
      if (pointInInnerHex(cx,cy)) return false;
      return true;
    }

    function draw() {
      ctx.clearRect(0,0,W,H);

      // background
      ctx.fillStyle = '#0a0a0a';
      ctx.fillRect(0,0,W,H);

      // base fill inside outer hex
      ctx.save();
      ctx.clip(outerHexPath);
      ctx.fillStyle = '#141414';
      ctx.fillRect(0,0,W,H);

      // grid lines (only inside hex clip)
      ctx.strokeStyle = 'rgba(255,255,255,0.07)';
      ctx.lineWidth = 1;
      for (let x=0; x<=W; x+=gridSize){
        ctx.beginPath();
        ctx.moveTo(x,0);
        ctx.lineTo(x,H);
        ctx.stroke();
      }
      for (let y=0; y<=H; y+=gridSize){
        ctx.beginPath();
        ctx.moveTo(0,y);
        ctx.lineTo(W,y);
        ctx.stroke();
      }

      // fill placed cells
      for (const [key,val] of placed.entries()){
        const [c,r] = key.split(',').map(Number);
        const rect = cellRect(c,r);
        ctx.fillStyle = val.color;
        ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
      }

      // selection preview (only for empty cells)
      for (const key of selected){
        if (placed.has(key)) continue;
        const [c,r] = key.split(',').map(Number);
        const rect = cellRect(c,r);
        ctx.fillStyle = selectedColor + '66';
        ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
      }

      ctx.restore();

      // outer hex outline
      ctx.strokeStyle = 'rgba(255,255,255,0.28)';
      ctx.lineWidth = 2;
      ctx.shadowBlur = 14;
      ctx.shadowColor = 'rgba(255,255,255,0.2)';
      ctx.stroke(outerHexPath);
      ctx.shadowBlur = 0;

      // inner hex (desert)
      ctx.fillStyle = '#8B5A3C';
      ctx.fill(innerHexPath);
      ctx.strokeStyle = 'rgba(255,255,255,0.35)';
      ctx.lineWidth = 2;
      ctx.stroke(innerHexPath);

      // Turrets: T1 bottom-left (index 4), T2 top-left (2), T3 right (0)
      const turrets = [
        { index: 4, label: 'T1' },
        { index: 2, label: 'T2' },
        { index: 0, label: 'T3' },
      ];
      turrets.forEach(t => {
        const v = hexVertex(t.index, innerRadius);
        ctx.fillStyle = '#2196F3';
        ctx.beginPath();
        ctx.arc(v.x, v.y, 18, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 16px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(t.label, v.x, v.y);
      });

      // Capital C
      ctx.fillStyle = '#2196F3';
      ctx.beginPath();
      ctx.arc(centerX, centerY, 38, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 3;
      ctx.stroke();
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 34px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('C', centerX, centerY);

      // Alliance labels: per group centroid
      const groups = new Map();
      for (const [key,val] of placed.entries()){
        if (!groups.has(val.groupId)) groups.set(val.groupId, { name: val.name, color: val.color, cells: [] });
        groups.get(val.groupId).cells.push(key);
      }

      ctx.font = 'bold 14px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      for (const g of groups.values()){
        let sx=0, sy=0;
        for (const key of g.cells){
          const [c,r] = key.split(',').map(Number);
          const rect = cellRect(c,r);
          sx += rect.x + rect.w/2;
          sy += rect.y + rect.h/2;
        }
        const cx = sx / g.cells.length;
        const cy = sy / g.cells.length;

        ctx.save();
        ctx.fillStyle = '#fff';
        ctx.strokeStyle = 'rgba(0,0,0,0.8)';
        ctx.lineWidth = 4;
        ctx.strokeText(g.name, cx, cy);
        ctx.fillText(g.name, cx, cy);
        ctx.restore();
      }

      updateLegend();
    }

    // Selection from drag: rectangle selection in cell space, but only playable cells.
    function cellsInDrag(startKey, endKey){
      const [sc,sr] = startKey.split(',').map(Number);
      const [ec,er] = endKey.split(',').map(Number);
      const minC = Math.min(sc,ec), maxC = Math.max(sc,ec);
      const minR = Math.min(sr,er), maxR = Math.max(sr,er);
      const result = new Set();
      for (let r=minR;r<=maxR;r++){
        for (let c=minC;c<=maxC;c++){
          const key = `${c},${r}`;
          if (!cellIsPlayable(c,r)) continue;
          if (placed.has(key)) continue;
          result.add(key);
        }
      }
      return result;
    }

    function clientToCanvas(clientX, clientY){
      const rect = canvas.getBoundingClientRect();
      const scaleX = W / rect.width;
      const scaleY = H / rect.height;
      return {
        x: (clientX - rect.left) * scaleX,
        y: (clientY - rect.top) * scaleY,
      };
    }

    function startDragAt(clientX, clientY){
      const p = clientToCanvas(clientX, clientY);

      // Block selection if starting in inner hex (capital)
      if (pointInInnerHex(p.x,p.y)) return;

      const cell = pointToCell(p.x,p.y);
      const [c,r] = [cell.col, cell.row];
      if (!cellIsPlayable(c,r)) return;
      if (placed.has(cell.key)) return;

      isDragging = true;
      dragStartKey = cell.key;
      selected = new Set([cell.key]);
      draw();
    }

    function updateDragTo(clientX, clientY){
      if (!isDragging || !dragStartKey) return;
      const p = clientToCanvas(clientX, clientY);
      const cell = pointToCell(p.x,p.y);
      const [c,r] = [cell.col, cell.row];
      if (!cellIsPlayable(c,r)) return;
      selected = cellsInDrag(dragStartKey, cell.key);
      if (selected.size === 0) selected = new Set([dragStartKey]);
      draw();
    }

    function endDrag(){
      if (isDragging && selected.size > 0) openModal();
      isDragging = false;
      dragStartKey = null;
    }

    // Mouse
    canvas.addEventListener('mousedown', (e)=>{ e.preventDefault(); startDragAt(e.clientX, e.clientY); });
    canvas.addEventListener('mousemove', (e)=>{ e.preventDefault(); updateDragTo(e.clientX, e.clientY); });
    window.addEventListener('mouseup', ()=> endDrag());

    // Touch
    canvas.addEventListener('touchstart', (e)=>{ e.preventDefault(); const t=e.touches[0]; startDragAt(t.clientX, t.clientY); }, {passive:false});
    canvas.addEventListener('touchmove', (e)=>{ e.preventDefault(); const t=e.touches[0]; updateDragTo(t.clientX, t.clientY); }, {passive:false});
    window.addEventListener('touchend', ()=> endDrag());

    // Modal + legend
    function openModal(){
      document.getElementById('assignModal').style.display = 'block';
      document.getElementById('selectionLabel').textContent = `${selected.size} マス選択中`;
      setTimeout(()=>document.getElementById('allianceName').focus(), 50);
    }

    function closeModal(){
      document.getElementById('assignModal').style.display = 'none';
      selected = new Set();
      dragStartKey = null;
      draw();
    }

    function clearSelection(){
      document.getElementById('allianceName').value = '';
      closeModal();
    }

    function assignAlliance(){
      const name = document.getElementById('allianceName').value.trim();
      if (!name){ alert('同盟名を入力してください！'); return; }

      const groupId = Date.now();
      for (const key of selected){
        placed.set(key, { name, color: selectedColor, groupId });
      }

      document.getElementById('allianceName').value = '';
      closeModal();
      draw();
    }

    window.deleteAlliance = function(allianceName){
      if (!confirm(`「${allianceName}」を削除しますか？`)) return;
      for (const [key,val] of placed.entries()){
        if (val.name === allianceName) placed.delete(key);
      }
      draw();
    };

    function updateLegend(){
      const legendList = document.getElementById('legendList');
      legendList.innerHTML = '';

      if (placed.size === 0){
        legendList.innerHTML = '<div style="color: rgba(255,255,255,0.5); font-size: 0.9em; padding: 0 10px; white-space: nowrap;">配置なし</div>';
        return;
      }

      const unique = new Map();
      for (const v of placed.values()){
        if (!unique.has(v.name)) unique.set(v.name, v.color);
      }

      for (const [name,color] of unique.entries()){
        const item = document.createElement('div');
        item.className = 'legend-item';
        const safeName = name.replace(/'/g, "\\'");
        item.innerHTML = `
          <div class="legend-color" style="background:${color}"></div>
          <span class="legend-name">${name}</span>
          <button class="delete-alliance-btn" type="button" onclick="window.deleteAlliance('${safeName}')">✕</button>
        `;
        legendList.appendChild(item);
      }
    }

    function initColorPicker(){
      const picker = document.getElementById('colorPicker');
      picker.innerHTML = '';
      colors.forEach((c, i)=>{
        const opt = document.createElement('div');
        opt.className = 'color-option' + (i===0 ? ' selected':'');
        opt.style.background = c;
        opt.addEventListener('click', ()=>{
          selectedColor = c;
          document.querySelectorAll('.color-option').forEach(o=>o.classList.remove('selected'));
          opt.classList.add('selected');
          draw();
        });
        picker.appendChild(opt);
      });
    }

    // Expose modal funcs
    window.closeModal = closeModal;
    window.clearSelection = clearSelection;
    window.assignAlliance = assignAlliance;

    initColorPicker();
    draw();
  </script>
</body>
</html>
